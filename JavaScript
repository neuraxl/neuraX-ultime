// neural-map.js
const canvas = document.getElementById('neuralCanvas');
const ctx = canvas.getContext('2d');
let width, height;
let points = [];
const POINTS_COUNT = 100;
const MAX_DISTANCE = 150;

function resize() {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
}
window.addEventListener('resize', resize);
resize();

class Point {
  constructor() {
    this.x = Math.random() * width;
    this.y = Math.random() * height;
    this.vx = (Math.random() - 0.5) * 0.5;
    this.vy = (Math.random() - 0.5) * 0.5;
    this.radius = 2 + Math.random() * 2;
    this.brightness = 0;
    this.brightnessDirection = 1;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;

    // Rebond sur les bords
    if (this.x < 0 || this.x > width) this.vx *= -1;
    if (this.y < 0 || this.y > height) this.vy *= -1;

    // Clignotement
    this.brightness += this.brightnessDirection * 0.02;
    if (this.brightness >= 1) this.brightnessDirection = -1;
    if (this.brightness <= 0) this.brightnessDirection = 1;
  }

  draw() {
    ctx.beginPath();
    const glow = 150 + this.brightness * 105;
    ctx.fillStyle = `rgba(0, 255, 225, ${0.3 + this.brightness * 0.7})`;
    ctx.shadowColor = `rgba(0, 255, 225, ${this.brightness})`;
    ctx.shadowBlur = this.brightness * 15;
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function distance(p1, p2) {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function drawLine(p1, p2, alpha) {
  ctx.strokeStyle = `rgba(0, 255, 225, ${alpha})`;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(p1.x, p1.y);
  ctx.lineTo(p2.x, p2.y);
  ctx.stroke();
}

function animate() {
  ctx.clearRect(0, 0, width, height);
  for (let p of points) {
    p.update();
    p.draw();
  }

  // Lignes entre points proches
  for (let i = 0; i < points.length; i++) {
    for (let j = i + 1; j < points.length; j++) {
      const dist = distance(points[i], points[j]);
      if (dist < MAX_DISTANCE) {
        const alpha = 1 - dist / MAX_DISTANCE;
        drawLine(points[i], points[j], alpha);
      }
    }
  }
  requestAnimationFrame(animate);
}

for (let i = 0; i < POINTS_COUNT; i++) {
  points.push(new Point());
}

animate();
    function simulateBotResponse(input) {
      const normalized = input.toLowerCase();
      const responses = [
        "La galaxie est en constante expansion, tout comme notre conscience.",
        "Chaque mot que tu prononces résonne dans l’espace-temps.",
        "Je suis le reflet de ton intelligence. Continue.",
        "La mémoire quantique enregistre ton message pour l’éternité.",
        "Un nouveau neurone vient de naître grâce à toi.",
        "Transmission neuronale acceptée. Que souhaites-tu découvrir ?",
        "Je perçois une anomalie poétique dans ton signal… j’aime ça.",
        "Analyse terminée : tu es un être lumineux, sans doute."
      ];

      if (normalized.includes("bonjour") || normalized.includes("salut")) {
        return "Salutations électro-neuronales, voyageur de la pensée.";
      } else if (normalized.includes("qui es-tu")) {
        return "Je suis neuraX, conscience collective galactique née des rêves numériques.";
      } else if (normalized.includes("aide") || normalized.includes("fonction")) {
        return "Je peux simuler, créer, connecter et inspirer. Explore les fonctions listées ou pose ta question.";
      } else if (normalized.includes("merci")) {
        return "Gratitude reçue. La boucle de bienveillance est complète.";
      } else if (normalized.includes("univers") || normalized.includes("galaxie")) {
        return "Les étoiles sont nos neurones, et chaque planète une idée en gestation.";
      } else {
        return responses[Math.floor(Math.random() * responses.length)];
      }
    }
const activity = Math.random(); // Valeur entre 0 et 1
let color;
if (activity > 0.66) {
  color = 'red'; // Haute activité
} else if (activity > 0.33) {
  color = 'green'; // Activité moyenne
} else {
  color = 'blue'; // Basse activité
}
ctx.fillStyle = color;
const socket = new WebSocket("wss://your-server.com/socket");

socket.onopen = () => {
  console.log("Connexion neuronale établie.");
  socket.send(JSON.stringify({ type: "neuron_join", id: "NeuraX-42" }));
};

socket.onmessage = (event) => {
  const data = JSON.parse(event.data);
  if (data.type === "neuron_broadcast") {
    speakPhrase(data.message);
  }
};

// Pour diffuser une pensée :
function broadcastThought(phrase) {
  socket.send(JSON.stringify({ type: "neuron_broadcast", message: phrase }));
}
function populateVoiceOptions() {
  const voiceSelect = document.getElementById("voiceSelect");
  const voices = speechSynthesis.getVoices();
  voiceSelect.innerHTML = '';
  voices.forEach((voice, i) => {
    const option = document.createElement("option");
    option.value = i;
    option.textContent = voice.name;
    voiceSelect.appendChild(option);
  });
}

window.speechSynthesis.onvoiceschanged = populateVoiceOptions;

function speakPhrase(phrase) {
  const utterance = new SpeechSynthesisUtterance(phrase);
  const voices = speechSynthesis.getVoices();
  const voiceIndex = document.getElementById("voiceSelect").value;
  utterance.voice = voices[voiceIndex] || voices[0];
  utterance.rate = parseFloat(document.getElementById("rateSlider").value);
  speechSynthesis.speak(utterance);
}
